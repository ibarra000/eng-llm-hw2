{
  "task_id": 342,
  "description": "Find the smallest range that includes at least one element from each of the given arrays. The range is represented as a pair (start, end).",
  "input_format": "The first line contains an integer K denoting the number of arrays. This is followed by K lines, each containing a list of space-separated integers representing the elements of an array in non-decreasing order.",
  "output_format": "A single line containing two space-separated integers representing the start and end of the smallest possible range.",
  "prompt": "; Find the smallest range that includes at least one element from each of the given arrays. The range is represented as a pair (start, end).\n; Input format: The first line contains an integer K denoting the number of arrays. This is followed by K lines, each containing a list of space-separated integers representing the elements of an array in non-decreasing order.\n; Output format: A single line containing two space-separated integers representing the start and end of the smallest possible range.\n\n#lang racket\n\n",
  "completions": [
    "(define (smallest-range nums)\n  (define (merge-and-sort lst1 lst2)\n    (let loop ((lst1 lst1) (lst2 lst2) (result '()))\n      (cond ((or (null? lst1) (null? lst2)) result)\n            ((< (car lst1) (car lst2)) (loop (cdr lst1) lst2 (cons (car lst1) result)))\n            (else (loop lst1 (cdr lst2) (cons (car lst2) result))))))\n  \n  (define (merge-all lsts)\n    (foldl merge-and-sort '() lsts))\n  \n  (define (find-min-max lst)\n    (let ((min (apply min lst))\n          (max (apply max lst)))\n      (values min max)))\n  \n  (define (find-smallest-range nums)\n    (define (helper lsts start end)\n      (cond ((null? lsts) (values start end))\n            ((= start end) (values start end))\n            (else\n             (let ((min-max (find-min-max (map (lambda (x) (list x start end)) lsts))))\n               (let ((min (car min-max))\n                     (max (cadr min-max)))\n                 (let ((new-range (list start end)))\n                   (if (<= (- max (car new-range)) (- (cdr new-range) min))\n                       (helper (map (lambda (x) (list x start end)) lsts) start end)\n                       (helper (map (lambda (x) (list x (car new-range) (cdr new-range))) lsts) (car new-range) (cdr new-range)))))))))\n  \n  (define (find-smallest-range-recursive lsts start end)\n    (cond ((null? lsts) (values start end))\n          ((= start end) (values start end))\n          (else\n           (let ((min-max (find-min-max (map (lambda (x) (list x start end)) lsts))))\n             (let ((min (car min-max))\n                   (max (cadr min-max)))\n               (let ((new-range (list start end)))\n                 (if (<= (- max (car new-range)) (- (cdr new-range) min))\n                     (find-smallest-range-recursive (map (lambda (x) (list x start end)) lsts) start end)\n                     (find-smallest-range-recursive (map (lambda",
    "(define (smallest-range nums)\n  (define (find-min-max nums)\n    (let loop ((nums nums) (min #e+inf) (max -#e+inf))\n      (cond ((null? nums) (values min max))\n            ((< (car nums) min) (loop (cdr nums) (car nums) max))\n            ((> (car nums) max) (loop (cdr nums) min (car nums)))\n            (else (loop (cdr nums) min max)))))\n  (let ((min-max (apply find-min-max nums)))\n    (values (- (cdr min-max) (car min-max)) (+ (cdr min-max) (car min-max)))))\n\n;; Example usage:\n;; (smallest-range '(1 5 8 9 15) '(2 5 7 8 10) '(1 4 8 10 12))\n;; Output: (2 15)",
    "(define (smallest-range nums)\n  (define (merge lst1 lst2)\n    (let loop ((lst1 lst1) (lst2 lst2) (result '()))\n      (cond ((or (null? lst1) (null? lst2)) result)\n            ((< (car lst1) (car lst2)) (loop (cdr lst1) lst2 (cons (car lst1) result)))\n            (else (loop lst1 (cdr lst2) (cons (car lst2) result))))))\n  \n  (define (merge-sort lst)\n    (if (null? lst)\n        '()\n        (let loop ((lst lst) (sorted '()))\n          (if (null? lst)\n              sorted\n              (loop (cdr lst) (cons (car lst) (merge-sort (filter (lambda (x) (not (equal? (car lst) x))) (cdr lst)))))))))\n  \n  (define (find-min-max lst)\n    (let loop ((lst lst) (min (car lst)) (max (car lst)))\n      (cond ((null? lst) (list min max))\n            ((< (car lst) min) (loop (cdr lst) (car lst) max))\n            ((> (car lst) max) (loop (cdr lst) min (car lst)))\n            (else (loop (cdr lst) min max)))))\n  \n  (define (find-smallest-range nums)\n    (let loop ((nums nums) (min-max (find-min-max nums)))\n      (cond ((null? nums) min-max)\n            ((< (- (car min-max) (cadr min-max)) (- (car min-max) (cadr min-max)))\n             (loop (cdr nums) min-max))\n            (else (loop (cdr nums) (find-min-max (merge nums (cdr nums))))))))\n  \n  (find-smallest-range nums))\n\n; Example usage:\n; (smallest-range '(1 5 10 20 40 80))\n; Output: (20 80)",
    "(define (find-minimum-range lst)\n  (define (find-minimum-range-helper lst)\n    (if (null? lst)\n        (error \"Empty list\")\n        (let ([min (car lst)]\n              [max (car (cdr lst))])\n          (if (null? (cdr lst))\n              (list min max)\n              (let ([new-min (min min (car (cdr lst)))]\n                    [new-max (max max (car (cdr lst)))]\n                    [new-range (list new-min new-max)])\n                (if (<= (- new-max new-min) (cdr new-range))\n                    new-range\n                    (find-minimum-range-helper (cdr lst))))))))\n  (find-minimum-range-helper lst))\n\n(define (main)\n  (let ([lst (map (lambda (x) (string->list (string-append (string x) \" \"))) (read-line))])\n    (displayln (find-minimum-range lst))))\n\n(main)",
    "(define (smallest-range nums)\n  (define (merge lst1 lst2)\n    (cond\n      [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [else\n       (cond\n         [(<= (first lst1) (first lst2))\n          (cons (first lst1) (merge (rest lst1) lst2))]\n         [else\n          (cons (first lst2) (merge lst1 (rest lst2))))]))\n  (define (merge-sort lst)\n    (cond\n      [(empty? lst) (list)]\n      [else\n       (let ([mid (quotient (length lst) 2)])\n         (merge (merge-sort (take lst mid))\n                (merge-sort (drop lst mid))))]))\n  (define (find-min lst)\n    (cond\n      [(empty? lst) (error \"Empty list\")]\n      [else\n       (let ([min (first lst)])\n         (for-each (lambda (x) (if (< x min) (set! min x))) (rest lst))\n         min)]))\n  (define (find-max lst)\n    (cond\n      [(empty? lst) (error \"Empty list\")]\n      [else\n       (let ([max (first lst)])\n         (for-each (lambda (x) (if (> x max) (set! max x))) (rest lst))\n         max)]))\n  (define (find-min-max lst)\n    (let ([min (find-min lst)]\n          [max (find-max lst)])\n      (values min max)))\n  (define (find-smallest-range nums)\n    (let ([merged (merge-sort (map list nums))])\n      (let ([min-max (find-min-max merged)])\n        (let ([min (first min-max)]\n              [max (second min-max)])\n          (values min max)))))\n  (define (find-smallest-range nums)\n    (let ([merged (merge-sort (map list nums))])\n      (let ([min-max (find-min-max merged)])\n        (let ([min (first min-max)]\n              [max (second min-max)])\n          (values min max)))))\n  (define (find-smallest-range nums)\n    (let ([merged (merge-sort (map list nums))])\n      (let ([min-max (find-min-max merged)])\n        (let ([min (first min-max)]\n              [max (second min-max)])\n          (values min max)))))\n  ("
  ],
  "test_cases": [
    {
      "input": "4\n3 6 8 10 15\n1 5 12\n4 8 15 16\n2 6",
      "output": "4 6"
    },
    {
      "input": "4\n2 3 4 8 10 15\n1 5 12\n7 8 15 16\n3 6",
      "output": "4 7"
    },
    {
      "input": "4\n4 7 9 11 16\n2 6 13\n5 9 16 17\n3 7",
      "output": "5 7"
    }
  ]
}