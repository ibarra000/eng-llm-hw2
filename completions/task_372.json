{
  "task_id": 372,
  "description": "Sort a given list of elements in ascending order using the heap queue algorithm.",
  "input_format": "A single line containing a list of integers separated by spaces.",
  "output_format": "A single line containing the sorted integers separated by spaces.",
  "prompt": "; Sort a given list of elements in ascending order using the heap queue algorithm.\n; Input format: A single line containing a list of integers separated by spaces.\n; Output format: A single line containing the sorted integers separated by spaces.\n\n#lang racket\n\n",
  "completions": [
    ";; Example usage:\n;; (sort-heap '(3 1 4 1 5 9 2 6 5 3 5))\n;; Expected output: (1 1 2 3 3 4 5 5 5 6 9)\n\n(define (sort-heap lst)\n  (define (heap-insert heap item)\n    (cond\n      [(empty? heap) (cons item empty)]\n      [else\n        (cond\n          [(<= (first heap) item) (cons item heap)]\n          [else (cons (first heap) (heap-insert (rest heap) item))])]))\n\n  (define (heap-merge heap1 heap2)\n    (cond\n      [(empty? heap1) heap2]\n      [(empty? heap2) heap1]\n      [else\n        (cond\n          [(<= (first heap1) (first heap2)) (cons (first heap1) (heap-merge (rest heap1) heap2))]\n          [else (cons (first heap2) (heap-merge heap1 (rest heap2)))]))]))\n\n  (define (heap-sort lst)\n    (define (heapify heap)\n      (cond\n        [(empty? (rest heap)) heap]\n        [else\n          (cond\n            [(<= (first heap) (first (rest heap))) (heapify (rest heap))]\n            [else (cons (first heap) (heapify (rest heap)))]))])\n\n    (define (build-heap lst)\n      (define (build-heap-iter heap lst)\n        (cond\n          [(empty? lst) heap]\n          [else\n            (let ([item (first lst)])\n              (build-heap-iter (heap-insert heap item) (rest lst)))]))\n\n      (build-heap-iter empty lst))\n\n    (define (heap-merge-iter heap1 heap2)\n      (cond\n        [(empty? heap1) heap2]\n        [(empty? heap2) heap1]\n        [else\n          (cond\n            [(<= (first heap1) (first heap2)) (heap-merge-iter (rest heap1) heap2)]\n            [else (heap-merge-iter heap1 (rest heap2))]))])\n\n    (define (heap-merge-iter-2 heap1 heap2)\n      (cond\n        [(empty? heap1) heap2]\n        [(empty? heap2)",
    ";; Function to sort a list of integers in ascending order using the heap queue algorithm\n(define (heap-sort lst)\n  (define (heap-insert heap item)\n    (if (null? heap)\n        (list item)\n        (let ((new-heap (cons item heap)))\n          (if (> (car new-heap) (cadr new-heap))\n              (list (cadr new-heap) (car new-heap))\n              new-heap))))\n  \n  (define (heap-merge heap1 heap2)\n    (if (null? heap1)\n        heap2\n        (if (null? heap2)\n            heap1\n            (if (> (car heap1) (car heap2))\n                (list (car heap2) (cadr heap2) (caddr heap2) (cadr heap1) (caddr heap1))\n                (list (car heap1) (cadr heap1) (caddr heap1) (car heap2) (cadr heap2))))))\n  \n  (define (heap-merge-sort lst)\n    (if (null? lst)\n        '()\n        (let ((heap (list (car lst))))\n          (for-each (lambda (item)\n                      (set! heap (heap-merge heap (heap-insert heap item))))\n                    (cdr lst))\n          (reverse (list (car heap) (cadr heap) (caddr heap))))))\n  \n  (heap-merge-sort lst))\n\n;; Example usage:\n;; (heap-sort '(3 1 4 1 5 9 2 6 5 3 5))\n;; Expected output: (1 1 2 3 3 4 5 5 5 6 9)",
    ";; Example usage:\n;; (sort-heap '(3 1 4 1 5 9 2 6 5 3 5)) => (1 1 2 3 3 4 5 5 5 6 9)\n\n(define (sort-heap lst)\n  (define (heap-insert heap item)\n    (if (null? heap)\n        (list item)\n        (if (< (car heap) item)\n            (cons item heap)\n            (cons (car heap) (heap-insert (cdr heap) item)))))\n\n  (define (heap-merge heap1 heap2)\n    (if (null? heap1)\n        heap2\n        (if (null? heap2)\n            heap1\n            (if (< (car heap1) (car heap2))\n                (cons (car heap1) (heap-merge (cdr heap1) heap2))\n                (cons (car heap2) (heap-merge heap1 (cdr heap2)))))))\n\n  (define (heap-merge-all heaps)\n    (if (null? heaps)\n        '()\n        (if (null? (cdr heaps))\n            (car heaps)\n            (heap-merge (car heaps) (heap-merge-all (cdr heaps)))))\n\n  (define (heapify lst)\n    (define (heapify-internal lst start end)\n      (if (< start end)\n          (let* ((mid (quotient (+ start end) 2))\n                 (left (heapify-internal lst start mid))\n                 (right (heapify-internal lst (+ start 1) end))\n                 (new-left (if (null? left) #f left))\n                 (new-right (if (null? right) #f right)))\n            (if (and new-left new-right)\n                (if (< (car left) (car right))\n                    (cons (car left) (heapify-internal lst (+ start 1) end))\n                    (cons (car right) (heapify-internal lst (+ start 1) end)))\n                (cons (car lst) (heapify-internal lst (+ start 1) end)))))\n          lst))\n    (heapify-internal lst 0 (sub1 (length lst))))\n\n  (define (heap-sort lst)\n    (define (heap-sort-internal lst)\n      (if (null? lst)\n          '()\n          (let* ((root (car lst))\n                 (rest (cdr lst",
    ";; Example usage:\n;; (sort-heap '(3 1 4 1 5 9 2 6 5 3 5)) => (1 1 2 3 3 4 5 5 5 6 9)\n\n(define (sort-heap lst)\n  (define (heap-insert heap item)\n    (if (null? heap)\n        (list item)\n        (let ((new-heap (cons item heap)))\n          (if (<= (car new-heap) (cadr new-heap))\n              new-heap\n              (cons (cadr new-heap) (heap-insert (cadr new-heap) (car new-heap)))))))\n\n  (define (heap-merge heap1 heap2)\n    (if (null? heap1)\n        heap2\n        (if (null? heap2)\n            heap1\n            (let ((item1 (car heap1))\n                  (item2 (car heap2)))\n              (if (<= item1 item2)\n                  (cons item1 (heap-merge (cdr heap1) heap2))\n                  (cons item2 (heap-merge heap1 (cdr heap2))))))))\n\n  (define (heap-sort lst)\n    (define (heapify heap)\n      (let loop ((heap heap))\n        (if (null? heap)\n            heap\n            (let ((item (car heap))\n                  (rest (cdr heap)))\n              (if (<= item (car rest))\n                  (cons item (loop rest))\n                  (cons (car rest) (loop (cons item (cdr rest))))))))\n    (define (build-heap lst)\n      (let loop ((lst lst)\n                 (heap '()))\n        (if (null? lst)\n            heap\n            (let ((item (car lst))\n                  (rest (cdr lst)))\n              (loop rest (heap-insert heap item))))))\n    (let ((heap (build-heap lst)))\n      (let loop ((heap heap))\n        (if (null? heap)\n            '()\n            (let ((item (car heap))\n                  (rest (cdr heap)))\n              (loop (heap-merge (cdr heap) (list item))))))))\n\n(sort-heap '(3 1 4 1 5 9 2 6 5 3 5))",
    ";; Example usage:\n;; (sort-heap '(3 1 4 1 5 9 2 6 5 3 5)) => (1 1 2 3 3 4 5 5 5 6 9)\n\n(define (sort-heap lst)\n  (define (heap-insert heap item)\n    (if (null? heap)\n        (list item)\n        (if (< (car heap) item)\n            (cons item heap)\n            (cons (car heap) (heap-insert (cdr heap) item)))))\n\n  (define (heap-merge heap1 heap2)\n    (if (null? heap1)\n        heap2\n        (if (null? heap2)\n            heap1\n            (if (< (car heap1) (car heap2))\n                (cons (car heap1) (heap-merge (cdr heap1) heap2))\n                (cons (car heap2) (heap-merge heap1 (cdr heap2)))))))\n\n  (define (heap-merge-all heaps)\n    (if (null? heaps)\n        '()\n        (if (null? (cdr heaps))\n            (car heaps)\n            (heap-merge (car heaps) (heap-merge-all (cdr heaps)))))\n\n  (define (heapify heap)\n    (if (null? heap)\n        heap\n        (if (null? (cdr heap))\n            (list (car heap))\n            (if (< (car heap) (cadr heap))\n                (cons (car heap) (heapify (cdr heap)))\n                (cons (cadr heap) (heapify (car heap)))))))\n\n  (define (heap-sort lst)\n    (define (heapify-heap heap)\n      (if (null? heap)\n          heap\n          (if (null? (cdr heap))\n              (list (car heap))\n              (if (< (car heap) (cadr heap))\n                  (cons (car heap) (heapify-heap (cdr heap)))\n                  (cons (cadr heap) (heapify-heap (car heap)))))))\n\n    (define (heap-merge-heap heap1 heap2)\n      (if (null? heap1)\n          heap2\n          (if (null? heap2)\n              heap1\n              (if (< (car heap1) (car heap2))\n                  (cons (car heap1) (heap-merge-heap (cdr heap1) heap2"
  ],
  "test_cases": [
    {
      "input": "18 14 10 9 8 7 9 3 2 4 1",
      "output": "1 2 3 4 7 8 9 9 10 14 18"
    },
    {
      "input": "25 35 22 85 14 65 75 25 58",
      "output": "14 22 25 25 35 58 65 75 85"
    },
    {
      "input": "1 3 5 7 9 2 4 6 8 0",
      "output": "0 1 2 3 4 5 6 7 8 9"
    }
  ]
}